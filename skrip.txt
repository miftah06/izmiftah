#v2

import base64
import csv
import keyword
import logging
import os
import random
import subprocess
import time
from datetime import datetime

import pandas as pd
import requests
import telebot
from googlesearch import search
from telegram import message
import urllib.parse
from autopdf import generate_html

# Ganti dengan token bot Telegram Anda
last_update_time = None
keywords_list = []
TOKEN = 'your-token-bot-id'
bot = telebot.TeleBot(TOKEN)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
api_key = 'your-deepai-api-key'


def send_formatted_message(chat_id, formatted_message):
    bot.reply_to(message, chat_id=chat_id, text=formatted_message)


def generate_prompt(prompt, api_key):
    try:
        url = "https://api.deepai.org/api/text-generator"
        headers = {
            "Content-Type": "application/json",
            "api-key": api_key
        }
        data = {
            "text": prompt
        }
        response = requests.post(url, json=data, headers=headers)

        if response.status_code == 200:
            result = response.json()
            if 'output' in result:
                return result['output']
            else:
                return f"Error in DeepAI response: {result}"
        else:
            error_message = response.json().get('details', {}).get('input', {}).get('failedConstraints',
                                                                                    'Unknown error')
            return f"Error in DeepAI request. Status code: {response.status_code}. Details: {error_message}"

    except Exception as e:
        return f"Error in DeepAI request. Exception: {str(e)}"


def generate_content(message_text, api_key, chat_id=message.Chat.id):
    try:
        prompt = f"Generate content: {message_text}"

        # Your code to generate content goes here!
        generated_content = generate_prompt(prompt, api_key)

        # Send the generated content as a message to the Telegram bot
        send_formatted_message(chat_id, generated_content)

        # Return a success message
        return "Message sent successfully!"

    except Exception as e:
        # Handle any exceptions that may occur
        return f"Error: {str(e)}"


def send_telegram_message(message):
    url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    params = {
        "chat_id": message.chat_id,
        "text": message
    }
    response = requests.post(url, params=params)
    if response.status_code != 200:
        raise Exception(f"Failed to send message to Telegram bot: {response.text}")


def generate_image(prompt, api_key):
    try:
        url = "https://api.deepai.org/api/text2img"
        headers = {
            "Content-Type": "application/json",
            "api-key": api_key
        }
        data = {
            "text": prompt
        }
        response = requests.post(url, json=data, headers=headers)

        if response.status_code == 200:
            result = response.json()
            if 'output_url' in result:
                return result['output_url']
            else:
                return f"Error in DeepAI response: {result}"
        else:
            error_message = response.json().get('details', {}).get('input', {}).get('failedConstraints',
                                                                                    'Unknown error')
            return f"Error in DeepAI request. Status code: {response.status_code}. Details: {error_message}"

    except Exception as e:
        return f"Error in DeepAI request. Exception: {str(e)}"


@bot.message_handler(commands=['ai2'])
def handle_ai2_prompt(update, context):
    try:
        message_text = update.message.text.split(' ', 1)[1] if len(
            update.message.text.split()) > 1 else "No prompt provided."

        # Generate image based on the provided prompt
        generated_image = generate_image(message_text, api_key)

        # Send the generated image as a message to the Telegram bot
        if generated_image.startswith('data:image/jpeg;base64,'):
            # If the image is base64 encoded, decode it and send as photo
            image_data = base64.b64decode(generated_image.replace('data:image/jpeg;base64,', ''))
            context.bot.send_photo(photo=image_data)
        else:
            # Otherwise, send it as a regular message with the image URL
            context.bot.reply_to(message, text=generated_image)

    except Exception as e:
        context.bot.reply_to(message, text=f"An error occurred: {str(e)}")
        bot.reply_to(message, text=f"An error occurred: {str(e)}")
    bot.reply_to(message, handle_ai2_prompt.result)
    bot.reply_to(message, generate_image.result)


def generate_keyword_file(filename, num_keywords):
    keyword_list = keyword.kwlist
    num_keywords = min(num_keywords, len(keyword_list))

    random_keywords = random.sample(keyword_list, num_keywords)

    with open(filename, "w") as file:
        file.write("\n".join(random_keywords))


@bot.message_handler(commands=['ai-prompt'])
def handle_prompt(message):
    args = message.text.split('/')[1:]

    if len(args) == 7:
        keyword1_file, keyword2_file, output_file, command_option, specification_option, prompt_type, additional_input = args

        # Generate keywoard files
        generate_keyword_file(keyword1_file, 500)
        generate_keyword_file(keyword2_file, 500)

        # Create prompt
        create_prompt(keyword1_file, keyword2_file, output_file, command_option, specification_option, prompt_type,
                      additional_input, message)

        # Send the output file to the user
        with open(output_file, 'r') as file:
            output_text = file.read()

        bot.reply_to(message, output_text)
    else:
        bot.reply_to(message,
                     "Format prompt tidak valid. Gunakan format /ai-prompt fitur.txt/objek.txt/ai.txt/kata_perintah/specification_option/prompt_type/jumlah")


@bot.message_handler(commands=['ai'])
def handle_ai_prompt(update, context, chat_id=message.Chat.id):
    global e
    try:
        message_text = update.message.text.split(' ', 1)[1] if len(
            update.message.text.split()) > 1 else "No prompt provided."

        # Generate content based on the provided prompt
        generated_content = generate_content(message_text, api_key)

        # Send generated content as a reply
        context.bot.reply_to(message, chat_id)

    except Exception as e:
        context.bot.reply_to(message, text=f"An error occurred: {str(e)}")
        bot.reply_to(message, text=f"An error occurred: {str(e)}")
    bot.reply_to(message, handle_ai_prompt.result)
    bot.reply_to(message, generate_prompt.result)


def create_prompt(keyword1_file, keyword2_file, output_file, command_option, specification_option, prompt_type,
                  additional_input, message):
    with open("skrip.txt", "r") as parno_file:
        parno_options = parno_file.readlines()
        prompt = random.choice(parno_options).strip()
    with open(keyword1_file, "r") as key1_file, open(keyword2_file, "r") as key2_file, open(output_file, "w") as file:
        key1_options = key1_file.readlines()
        key2_options = key2_file.readlines()
        key1_option = random.choice(key1_options).strip()
        key2_option = random.choice(key2_options).strip()
        paragraf = additional_input.strip()

        try:
            subprocess.run(['bash', 'key.sh'], check=True)
            bot.reply_to(message,
                         f"Ai prompt sudah terkespor ke {output_file}\nSilahkan jalankan /keyword lalu /download-hasil \n lalu /download2 untuk output.txt sebagai /ai /command/command/output.txt atau ai.txt untuk /download3.")
        except subprocess.CalledProcessError as e:
            bot.reply_to(message, f"Error: {e}")
        if prompt_type == "text":
            output_line = f"Generate text with command:\n\n\n {command_option} {specification_option} serta {key1_option}\n dengan tambahan fungsi {key2_option}\n adapun jika isinya berupa {prompt} {key1_option}\n\n dengan skrip:\n\n{prompt} bersama fungsi atau pembahasan mengenai {key2_option} serta berikan saya detail lengkapnya \n\n\n"
        elif prompt_type == "image":
            output_line = f"Generate image with command:\n\n\n {command_option}, dengan latar elegant dengan penuh estetika nuansa {specification_option} bertemakan {key1_option} dengan warna {key2_option}\n\n\n"
        elif prompt_type == "script":
            output_line = f"Generate script with command:\n\n\n {command_option}{specification_option} dan serta {prompt} jika hal tersebut berupa\n {prompt}\n dengan {key1_option}\n\n di dalam skrip {parno_options} {key1_option}\n dengan module atau plugin tambahan {prompt}{key2_option}\n\n\npada untuk {specification_option} dan berikan saya skrip lengkapnya\n\n\n\n"
        elif prompt_type == "soal":
            output_line = f"Generate answer with command:\n\n\n {command_option}{specification_option} dan jawablah jika soalnya:\n {prompt}\n tanpa {key1_option}\n\n maka tolong jawab {parno_options} {key1_option}\n dengan menjelaskan {prompt}{key2_option}\n\n\n {specification_option} secara rinci\n sebanyak {paragraf} soal serta berikan saya jawaban lengkapnya\n\n"
        elif prompt_type == "cerita":
            output_line = f"Generate story with command:\n\n\n {command_option}, dengan latar elegant dengan penuh estetika nuansa {specification_option} bertemakan {key1_option} dengan warna {key2_option}\n\n\n{command_option}{specification_option} dan buatlah momen lucu setelah terjadi kejadian berupa\n\n {prompt}\n\n\n dan buatlah ceritanya dengan penuh drama dan lelucon keharmonisan\n\n dan jangan lupa buat ulang dengan tema:\n {key1_option}\n dengan menambahkan tambahkan {prompt}\n {specification_option} di dalam ceritanya\n\n sebanyak {paragraf} paragraf\n\n"
        else:
            output_line = "Invalid prompt type\n masukkan opsi\n 1.image,\n 2.text atau\n 3.script\n"
        file.write(output_line)
        bot.reply_to(message,
                     f"silahkan jalankan /ai dengan text di dalam {output_file} atau dengan menggunakan /ai2 untuk gambar")


def get_dns_info(hostname):
    try:
        # Scanning CNAME
        cname_result = subprocess.check_output(['nslookup', '-type=CNAME', hostname], universal_newlines=True)
        cname_values = [line.split(':')[-1].strip() for line in cname_result.splitlines() if
                        'canonical name' in line.lower()]
    except subprocess.CalledProcessError:
        cname_values = None

    try:
        # Scanning IPv4
        ipv4_result = subprocess.check_output(['nslookup', '-type=A', hostname], universal_newlines=True)
        ipv4_addresses = [line.split(':')[-1].strip() for line in ipv4_result.splitlines() if 'address' in line.lower()]
    except subprocess.CalledProcessError:
        ipv4_addresses = None

    try:
        # Scanning IPv6
        ipv6_result = subprocess.check_output(['nslookup', '-type=AAAA', hostname], universal_newlines=True)
        ipv6_addresses = [line.split(':')[-1].strip() for line in ipv6_result.splitlines() if 'address' in line.lower()]
    except subprocess.CalledProcessError:
        ipv6_addresses = None

    return cname_values, ipv4_addresses, ipv6_addresses


@bot.message_handler(commands=['dnsinfo'])
def handle_dnsinfo(message):
    domain = message.text.split()[1]
    cname_values, ipv4_addresses, ipv6_addresses = get_dns_info(domain)
    bot.reply_to(message, f"CNAME: {cname_values}\nIPv4: {ipv4_addresses}\nIPv6: {ipv6_addresses}")
    time.sleep(10)  # Add a delay of 10 seconds


def extract_domain(url):
    try:
        domain = url.split('//')[1].split('/')[0]
    except IndexError:
        print(f"Error extracting domain from URL: {url}")
        return None
    return domain

def scrape_domain(keyword):
    print(f"Mencari: {keyword}")
    results = []

    try:
        for url in search(keyword, num=3, stop=3, pause=5):  # Jeda waktu 5 detik antara setiap permintaan
            bot.reply_to(message, f"URL ditemukan: {url}")
            print(f"URL ditemukan: {url}")
            domain = extract_webdomain(url)
            if domain:
                result = {'Keyword': keyword, 'URL': url, 'Domain': domain}
                results.append(result)
    except Exception as e:
        bot.reply_to(message, f"Error dalam proses scraping: {e}")

    return results

def extract_webdomain(url):
    try:
        domain = urllib.parse.urlparse(url).hostname
    except Exception:
        print(f"Error mengekstrak domain dari URL: {url}")
        return None
    return domain

@bot.message_handler(commands=['dork'])
def handle_dork(message):
    try:
        _, keywords_line, domain_extensions_line = message.text.split('/')
    except ValueError:
        bot.reply_to(message, "Format tidak valid. Gunakan /dork <keywords>/<domain_extensions>")
        return

    keywords = keywords_line.split(',')
    domain_extensions = domain_extensions_line.split(',')
    all_results = []

    for keyword in keywords:
        for domain_extension in domain_extensions:
            formatted_keyword = f"{keyword} site:{domain_extension}"
            results = scrape_domain(formatted_keyword)
            all_results.extend(results)

    if all_results:
        formatted_results = "\n".join([f"{result['Keyword']}: {result['URL']}" for result in all_results])
        bot.reply_to(message, scrape_domain.url)
    else:
        bot.reply_to(message, "Tidak ada hasil ditemukan.")

def scan_subdomain(domain):
    subdomains = []
    with open("subdomains.txt", "r") as subdomain_file:
        subdomains = subdomain_file.read().splitlines()
    domain_results = []
    for subdomain in subdomains:
        url = f"https://{subdomain}.{domain}"
        try:
            response = requests.get(url)
            if response.status_code in [200, 301, 400, 409, 502, 401]:
                server_info = response.headers.get('Server', 'N/A')
                print(f"Subdomain found: {url} | Status Code: {response.status_code} | Server: {server_info}\n")
                domain_results.append(url)
        except requests.RequestException:
            pass
    with open("output.txt", "w") as output_file:
        for result in domain_results:
            output_file.write(f"{result}\n")
    return domain_results


@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    bot.reply_to(message, f"Hello, welcome to my Bot! Please format your message as follows: /write or /ai [Keyword] then /update or /keyword\n /dork for seraching and /scan for scanning subdomains")


@bot.message_handler(commands=['scan'])
def handle_subdomain_query(message):
    domain = message.text.split()[-1]  # assuming the domain is the last text after the command
    results = scan_subdomain(domain)
    bot.reply_to(message, f"Subdomain scan results: {results}")


def check_cover_png():
    file_path = 'cover.png'
    if os.path.exists(file_path) and os.path.getsize(file_path) == 0:
        return True
    return False


@bot.message_handler(commands=['write'])
def get_random_text(message):
    global last_update_time, keywords_list

    # Periksa apakah file katakunci.csv perlu diperbarui
    current_time = datetime.now()
    if last_update_time is None or (current_time - last_update_time).days >= 1:
        if update_keywordnya():
            last_update_time = current_time
        else:
            bot.reply_to(message,
                         f"Maaf admin lupa mengupdate database untuk penulisan. \n Silahkan upload keyword.txt berupa bahan tulisan \n dan Coba lagi nanti.")
            return

    # Example data
    data = {
        'Logo': ['Logo Value'],
        'Bab': ['Bab Value'],
        'Subjudul 1': ['Subjudul 1 Value'],
        'Opsional 1': ['Opsional 1 Value'],
        'Opsional 2': ['Opsional 2 Value'],
        'Opsional 3': ['Opsional 3 Value'],
        'Opsional 4': ['Opsional 4 Value'],
        'Opsional 5': ['Opsional 5 Value'],
        'Opsional 6': ['Opsional 6 Value'],
        'Opsional 7': ['Opsional 7 Value'],
        'Opsional 8': ['Opsional 8 Value'],
        'Opsional 9': ['Opsional 9 Value'],
        'Opsional 10': ['Opsional 10 Value'],
        'Opsional 11': ['Opsional 11 Value'],
        'Opsional 12': ['Opsional 12 Value'],
        'Opsional 13': ['Opsional 13 Value'],
        'Opsional 14': ['Opsional 14 Value'],
        'Opsional 15': ['Opsional 15 Value'],
        'Opsional 16': ['Opsional 16 Value'],
        'Opsional 17': ['Opsional 17 Value'],
        'Opsional 18': ['Opsional 18 Value'],
        'Opsional 19': ['Opsional 19 Value'],
        'Opsional 20': ['Opsional 20 Value'],
        'Opsional 21': ['Opsional 21 Value'],
        # Add more columns as needed
    }

    # Create a DataFrame
    your_dataframe = pd.DataFrame(data)

    # Ganti fungsi pencarian Google dengan generate_html
    # Assuming your_dataframe contains the data you need
    generated_keyword = generate_html(your_dataframe)

    # Process the generated_keyword as needed

    bot.reply_to(message,
                 f"Intruksi!!: {generated_keyword} \n list file bahan: \n 1. katakunci.csv \n 2. keyword.txt \n 3. cover.xlsx \n 4. auto.xlsx \n 5. skrip.txt \n DAPATKAN DI https://github.com/miftah06/izmiftah/ \n")


@bot.message_handler(commands=['download3'])
def download_html(message):
    try:
        with open('ai.txt', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading txt output file: {e}")
        bot.reply_to(message, "Gagal mengunduh file txt. Coba lagi nanti.")


@bot.message_handler(commands=['download-cover'])
def download_keywords(message):
    global keywords_list

    try:
        with open('beauty-cover.pdf', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading keywords: {e}")
        bot.reply_to(message, "Gagal mengunduh file pdf. Coba lagi nanti.")


@bot.message_handler(commands=['download-final'])
def download_keywords(message):
    global keywords_list

    try:
        with open('final_output.pdf', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading keywords: {e}")
        bot.reply_to(message, "Gagal mengunduh file pdf. Coba lagi nanti.")


@bot.message_handler(commands=['download-hasil'])
def download_keywords(message):
    global keywords_list

    try:
        with open('hasil.txt', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading keywords: {e}")
        bot.reply_to(message, "Gagal mengunduh file txt. Coba lagi nanti.")


@bot.message_handler(commands=['download'])
def download_keywords(message):
    global keywords_list

    try:
        with open('output_novel.pdf', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading keywords: {e}")
        bot.reply_to(message, "Gagal mengunduh file pdf. Coba lagi nanti.")


@bot.message_handler(commands=['download_html'])
def download_html(message):
    try:
        with open('output.html', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading HTML: {e}")
        bot.reply_to(message, "Gagal mengunduh file HTML. Coba lagi nanti.")


@bot.message_handler(commands=['download2'])
def download_html(message):
    try:
        with open('output.txt', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading txt output file: {e}")
        bot.reply_to(message, "Gagal mengunduh file txt. Coba lagi nanti.")


@bot.message_handler(commands=['download_html1'])
def download_html(message):
    try:
        with open('cover.html', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading HTML: {e}")
        bot.reply_to(message, "Gagal mengunduh file HTML. Coba lagi nanti.")


@bot.message_handler(commands=['download_html2'])
def download_html(message):
    try:
        with open('pdf.html', 'rb') as f:
            bot.send_document(message.Chat.id, f)
    except Exception as e:
        print(f"Error downloading HTML: {e}")
        bot.reply_to(message, "Gagal mengunduh file HTML. Coba lagi nanti.")


@bot.message_handler(commands=['upload'])
def update_keywords(message):
    global keywords_list
    if check_cover_png():
        bot.reply_to(message,"cover.png kosong. Silahkan upload cover.png sebagai logo atau cover karya tulis atau novel Anda.")
    else:
        bot.reply_to(message, "Terima kasih! File cover.png sudah diunggah.")


    try:
        # Set a larger field size limit
        max_field_size = int(1e6)
        csv.field_size_limit(max_field_size)

        # Read the entire CSV file with Pandas
        df = pd.read_csv('keyword.txt', header=None)

        # Convert the first column to lowercase and extend the keywords list
        keywords_list.extend(df.iloc[:, 0].str.lower().tolist())

        return True
    except Exception as e:
        print(f"Error updating keywords: {e}")
        return False


def process_uploaded_file(file_path):
    # Implement your logic to process the uploaded file
    # For example, you can read the contents of the file
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
            # Process the content as needed
            print(f"Content of the uploaded file:\n{content}")
            return True
    except Exception as e:
        print(f"Error processing uploaded file: {e}")
        return False


@bot.message_handler(content_types=['document'])
def handle_uploaded_file(message):
    global keywords_list

    if message.document.file_name not in ['katakunci.csv', 'keyword.txt', 'skrip.txt', 'auto.xlsx', 'input.txt',
                                          'subdomains.txt', 'cover.png']:
        bot.reply_to(message,
                     "Mohon kirim file dengan nama 'katakunci.csv', 'keyword.txt', 'skrip.txt', 'auto.xlsx', 'input.txt', 'subdomains.txt', 'cover.png'.")
        return

    file_info = bot.get_file(message.document.file_id)
    downloaded_file = bot.download_file(file_info.file_path)

    with open(message.document.file_name, 'wb') as new_file:
        new_file.write(downloaded_file)

    if update_keywordnya():
        bot.reply_to(message, f"File {message.document.file_name} berhasil diunggah dan database diperbarui.")
    else:
        bot.reply_to(message, "Gagal memperbarui database. Coba lagi nanti.")


@bot.message_handler(commands=['update'])
def update_scripts(message):
    try:
        subprocess.run(['bash', 'run.sh'], check=True)
        bot.reply_to(message, "Skrip berhasil diperbarui.")
    except subprocess.CalledProcessError as e:
        bot.reply_to(message, f"Error: {e}")


@bot.message_handler(commands=['keyword'])
def update_scripts(message):
    try:
        subprocess.run(['bash', 'key.sh'], check=True)
        bot.reply_to(message, "Skrip berhasil diperbarui.")
    except subprocess.CalledProcessError as e:
        bot.reply_to(message, f"Error: {e}")


def update_keywordnya():
    global keywords_list

    try:
        with open('katakunci.csv', newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile)
            keywords_list = [row[0] for row in reader]
        return True
    except Exception as e:
        print(f"Error updating keywords: {e}")
        return False


# Tambahkan logika untuk memeriksa keberadaan file auto.xlsx
if not os.path.isfile('auto.xlsx'):
    # File auto.xlsx tidak ada, download atau generate
    try:
        subprocess.run(['wget', 'https://github.com/miftah06/skripsi/raw/master/bab-generator/input_data.xlsx'])
        subprocess.run(['wget', 'https://github.com/miftah06/skripsi/raw/master/cover-generator/cover.xlsx'])
        subprocess.run(['mv', 'input_data.xlsx', 'auto.xlsx'])
        print("File auto.xlsx berhasil di-download dan diubah namanya.")
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        print("Gagal mendownload atau mengubah nama file auto.xlsx.")
        # Tambahkan logika untuk menghasilkan file auto.xlsx


def generate_html(dataframe):
    # Your logic for generating HTML based on the dataframe goes here
    # Replace this with your actual implementation
    generated_html = f"jangan lupa /update terlebih dahulu \n silahkan /download.. dan tolong \n <html><body><h1> ganti bagian sini... untuk mengedit file htmlnya </h1></body></html>"
    return generated_html


if __name__ == '__main__':
    while True:
        try:
            bot.polling(none_stop=True)
        except Exception:
            time.sleep(10)
